## 페어의 피드백

### 좋았던 점

- 동갑이기도 하고 평소에 친하기도 해서 편하게 미션을 진행할 수 있었다.
- 자바스크립트를 잘 몰랐었는데 같이 하면서 많이 배울 수 있었다.
- 미션 중에 막히는 부분에 대해 하나하나 생각하는 시간을 가지면서 진행해서 속도는 느렸지만 배운게 많아서 좋았다.
- 미션 중에 몰입이 잘 되어서 매 순간 판단을 빠르게 할 수 있었다.



### 아쉬웠던 점

- 미션 기간 중에 각자의 일 때문에 일정이 안맞았던 것이 아쉽다.



## 리뷰어의 피드백

- 페이지에 대한 요청과 데이터에 대한 요청을 분리해라.

  - 페이지에 대한 요청은 `@Controller`로 분리해라.
  - `@ResquestMapping`을 통해 중복된 Path를 제거해라.

- 검증 로직을 추가해라.

  - 검증에 실패했을 경우 BadRequest를 발생시켜서 클라이언트에게 보내라.
  - 클라이언트에만 검증로직이 있을 경우 동일한 api를 사용하는 다른 클라이언트가 생긴다면 모든 클라이언트에 검증 로직을 추가해야한다.
  - 검증로직이 서버와 클라이언트 둘다 있으면 좋지만 서버에는 반드시 있어야 한다.
  - 검증이 여러 레이어에 있지만 각 레이어 별로 검증하는 목적이 다르다.
  - 컨트롤러에서 애노테이션으로 검증하는 부분이 도메인과 겹쳐 보일 수 있지만 올바른 요청 값을 보냈는지에 대한 검증과 객체 생성시 올바른 값이 있는지 에 대한 검증으로 서로 다른 검증이다.
  - 그래서 컨트롤러와 도메인간의 같았던 검증이 다를 수 도 있는데 a라는 필드가 객체 생성시에 null이면 안되는 조건이 있어도 Request 모델에서는 기본값을 가지고 있어 a를 null로 요청시 예외를 발생시키지 않고 기본값을 가지게 될 수도 있습니다.

- Request -> 도메인 변환을 컨트롤러에서 하지 마라.

  - request.toDomain()과 같은 메소드를 통해 변환해라.
    ```java
    Line line = new Line(name, color, startTime, endTime, intervalTime); // 이것 보다는
    lineRequest.toLine(); // 이것을 사용
    ```

- ResponseEntity가 아닌 `ResponseEntity<Void>` 와 같이 명시적으로 타입을 지정해라.

- `/lineStations/{lineId}/{stationId}` 와 같이 id가 연속적으로 나오면 어떤 id인지 판단할 수 없다.
  - `/lines/1/stations/1` 와 같이 REST API를 설계해야 한다.
  - URI 경로에는 소문자가 적합하다.
- 초기 데이터를 세팅해라.
  -  schema.sql에 스키마에 대한 정의를 작성하고 data.sql에 초기 데이터를 넣어라.
- try-catch, ExceptionHandler, ControllerAdvice의 차이
  - try-catch : 메소드 내에서 예외 처리
  - @ExceptionHandler : 컨트롤러단에서 처리
  - @ControllerAdvice : 전역으로 처리
- 도메인 모델과 ReponseDTO간에 필드를 1:1로 맞춰야 할 필요는 없다.
  - 응답할때 불필요하다고 생각하면 포함시키지 않아도 된다.
- @Transactional
  - 해당 메소드에 문제가 생겨서 처리가 중간에 끊겼을때 해당 트랜잭션을 롤백시켜 의도하지 않은 데이터 조작을 막을 수 있다. CUD 메소드를 Transactional로 만들면 적절하다.
- 커밋하기 직전에 전체 테스트를 돌려보면서 이상이 없는지 확인 해보는게 좋다.
  - 그래서 빠른 테스트가 중요하다. 테스트가 오래 걸린다면 자주 돌리는것이 부담이 되고 전체 테스트를 해보는 주기가 길어지게 된다.